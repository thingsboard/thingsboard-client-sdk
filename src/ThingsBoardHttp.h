#ifndef ThingsBoard_Http_h
#define ThingsBoard_Http_h

// Local includes.
#include "Constants.h"
#include "Telemetry.h"
#include "Helper.h"
#include "IHTTP_Client.h"
#include "DefaultLogger.h"


// HTTP topics.
char constexpr HTTP_TELEMETRY_TOPIC[] = "/api/v1/%s/telemetry";
char constexpr HTTP_ATTRIBUTES_TOPIC[] = "/api/v1/%s/attributes";
char constexpr HTTP_POST_PATH[] = "application/json";
int constexpr HTTP_RESPONSE_SUCCESS_RANGE_START = 200;
int constexpr HTTP_RESPONSE_SUCCESS_RANGE_END = 299;

// Log messages.
char constexpr POST[] = "POST";
char constexpr GET[] = "GET";
char constexpr HTTP_FAILED[] = "(%s) failed HTTP response (%d)";


/// @brief Wrapper around the ArduinoHttpClient to allow connecting and sending / retrieving data from ThingsBoard over the HTTP or HTTPS protocol
/// @note BufferSize of the underlying data buffer as well as the maximum amount of data points that can ever be sent have to defined as template arguments.
/// Changing is only possible if a new instance of this class is created. If these values should be changeable and dynamic instead.
/// Simply set THINGSBOARD_ENABLE_DYNAMIC to 1, before including ThingsBoardHttp.h
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = DefaultLogger
template<typename Logger = DefaultLogger>
class ThingsBoardHttpSized {
  public:
    /// @brief Constructs a instance with the given network client that should be used to establish the connection to ThingsBoard
    /// @note Directly connects to the given host over the given port
    /// @param client HTTP Client implementation that should be used to establish the connection to ThingsBoard
    /// @param access_token Non owning pointer to the access token used to verify the devices identity with the ThingsBoard server.
    /// Additionally it has to be kept alive by the user for the runtime of the HTTP or HTTPS connection
    /// @param host Non owning pointer to server instance name the client should connect too.
    /// Additionally it has to be kept alive by the user for the runtime of the HTTP client connection
    /// @param port Port that will be used to establish a connection and send / receive data.
    /// Should be either 80 for HTTP (unencrypted) or 443 for HTTPS (encrypted).
    /// The latter is recommended if relevant data is sent or if the client receives and handles Remote Procedure Calls or Shared Attribute Update Callbacks from the server,
    /// because using an unencrpyted connection, will allow 3rd parties to listen to the communication and impersonate the server sending payloads which might influence the device in unexpected ways.
    /// However if Over the Air udpates are enabled secure communication should definetly be enabled, because if that is not done a 3rd party might impersonate the server sending a malicious payload,
    /// which is then flashed onto the device instead of the real firmware. Which depeding on the payload might even be able to destroy the device or make it otherwise unusable.
    /// See https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/ for more information on the aforementioned security risk, default = 80
    /// @param keep_alive Attempts to keep the establishes TCP connection alive to make sending data faster, default = true
    /// @param max_stack_size Maximum amount of bytes we want to allocate on the stack.
    /// Is used when sending a lot of data at once over HTTP, because to actually send the JsonDocument data it first has to be serialized into a json string payload.
    /// To achieve this the data contained in the JsonDocument is copied for the scope of the @ref Send_Json method and is then copied into the outgoing HTTP buffer.
    /// This variable therefore decides the threshold where the JsonDocument is copied into the heap instead of a object on the stack.
    /// This is created to ensure no StackOverflow occurs because most supported boards run the actual sending code in a seperate FreeRTOS Task with limited stack space where even a stack allocation of 4 KiB might already cause a crash
    /// To circumvent this copy the alternative mentioned in the send_buffer_size argument can also be used because it skips the internal copy alltogether, because the JsonDocument is instead directly copied into the outgoing HTTP buffer, default = DEFAULT_MAX_STACK_SIZE (1024)
    ThingsBoardHttpSized(IHTTP_Client & client, char const * access_token, char const * host, uint16_t port = 80U, bool keep_alive = true, size_t const & max_stack_size = DEFAULT_MAX_STACK_SIZE)
      : m_client(client)
      , m_max_stack(max_stack_size)
      , m_token(access_token)
    {
        m_client.set_keep_alive(keep_alive);
        if (m_client.connect(host, port) != 0) {
            Logger::printfln(CONNECT_FAILED);
        }
    }

    /// @brief Sets the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead
    /// @note Is used when sending a lot of data at once over HTTP, because to actually send the JsonDocument data it first has to be serialized into a json string payload.
    /// To achieve this the data contained in the JsonDocument is copied for the scope of the @ref Send_Json method and is then copied into the outgoing HTTP buffer.
    /// This variable therefore decides the threshold where the JsonDocument is copied into the heap instead of a object on the stack.
    /// This is created to ensure no StackOverflow occurs because most supported boards run the actual sending code in a seperate FreeRTOS Task with limited stack space where even a stack allocation of 4 KiB might already cause a crash
    /// To circumvent this copy the alternative mentioned in the send_buffer_size argument of the constructor can also be used because it skips the internal copy alltogether, because the JsonDocument is instead directly copied into the outgoing HTTP buffer
    /// @param max_stack_size Maximum amount of bytes we want to allocate on the stack
    void Set_Maximum_Stack_Size(size_t const & max_stack_size) {
        m_max_stack = max_stack_size;
    }

    /// @brief Returns the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead
    /// @return Maximum amount of bytes we want to allocate on the stack
    size_t const & Get_Maximum_Stack_Size() const {
        return m_max_stack;
    }

    /// @brief Sends key-value pairs from the given JsonDocument over the given topic
    /// @note The passed JsonDocument data first has to be serialized into a json string payload to be then copied into the outgoing HTTP buffer
    /// @param topic Non owning pointer to topic that the message is sent over, where different HTTP topics expect a different kind of payload.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the given payload
    /// @param source JsonDocument containing our json key-value pairs,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @return Whether copying the payload contained in the source into the outgoing HTTP buffer, was successful or not
    bool Send_Json(char const * topic, JsonDocument const & source) {
        // Check if allocating needed memory failed when trying to create the JsonDocument,
        // if it did the isNull() method will return true. See https://arduinojson.org/v6/api/jsonvariant/isnull/ for more information
        if (source.isNull()) {
            Logger::printfln(UNABLE_TO_ALLOCATE_JSON);
            return false;
        }
        // Check if inserting any of the internal values failed because the JsonDocument was too small,
        // if it did the overflowed() method will return true. See https://arduinojson.org/v6/api/jsondocument/overflowed/ for more information
        if (source.overflowed()) {
            Logger::printfln(JSON_SIZE_TO_SMALL);
            return false;
        }
        bool result = false;

        size_t const json_size = Helper::Measure_Json(source);
        if (json_size > Get_Maximum_Stack_Size()) {
            char * json = new char[json_size]();
            if (serializeJson(source, json, json_size) < json_size - 1) {
                Logger::printfln(UNABLE_TO_SERIALIZE_JSON);
            }
            else {
                result = Send_Json_String(topic, json);
            }
            delete[] json;
            json = nullptr;
        }
        else {
            char json[json_size] = {};
            if (serializeJson(source, json, json_size) < json_size - 1) {
                Logger::printfln(UNABLE_TO_SERIALIZE_JSON);
                return result;
            }
            result = Send_Json_String(topic, json);
        }
        return result;
    }

    /// @brief Sends key-value pairs from the given json string over the given topic
    /// @param topic Non owning pointer to topic that the message is sent over, where different HTTP topics expect a different kind of payload.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the given payload
    /// @param json Non owning pointer to the string containing serialized json key-value pairs that should be copied into the outgoing HTTP buffer.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the given payload
    /// @return Whether copying the payload contained in the json string into the outgoing HTTP buffer, was successful or not
    bool Send_Json_String(char const * topic, char const * json) {
        if (json == nullptr || m_token == nullptr) {
            return false;
        }

        char path[Helper::Calculate_Print_Size(topic, m_token)] = {};
        (void)snprintf(path, sizeof(path), topic, m_token);
        return Post_Message(path, json);
    }

    //----------------------------------------------------------------------------
    // Telemetry API

    /// @brief Sends the given key-value pair as telemetry data.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @tparam T Type of the passed value
    /// @param key Non owning pointer to the key of the key-value pair.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the key-value pair
    /// @param value Value of the key-value pair
    /// @return Whether copying the key-value pair into the outgoing HTTP buffer, was successful or not
    template<typename T>
    bool Send_Telemetry_Data(char const * key, T const & value) {
        return Send_Key_Value_Pair(key, value);
    }

    /// @brief Send aggregated key-value pair as telemetry data
    /// @note Expects iterators to a container containing Telemetry class instances.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @tparam InputIterator Class that allows for forward incrementable access to data
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @tparam MaxKeyValuePairAmount Maximum amount of key-value pairs, which will ever be sent with this method.
    /// Should simply be the biggest distance between first and last iterator this method is ever called with
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
#if THINGSBOARD_ENABLE_DYNAMIC
    template<typename InputIterator>
#else
    template<size_t MaxKeyValuePairAmount, typename InputIterator>
#endif // THINGSBOARD_ENABLE_DYNAMIC
    bool Send_Telemetry(InputIterator const & first, InputIterator const & last) {
#if THINGSBOARD_ENABLE_DYNAMIC
        return Send_Data_Array(first, last, true);
#else
        return Send_Data_Array<MaxKeyValuePairAmount>(first, last, true);
#endif // THINGSBOARD_ENABLE_DYNAMIC
    }

    /// @brief Send string containing json as telemetry data.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @param json Non owning pointer to the string containing our json key-value pairs
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the key-value pairs
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
    bool Send_Telemetry_String(char const * json) {
        return Send_Json_String(HTTP_TELEMETRY_TOPIC, json);
    }

    /// @brief Send key-value pairs as telemetry data.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @param source JsonDocument containing our json key-value pairs,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
    bool Send_Telemetry_Json(JsonDocument const & source) {
        return Send_Json(HTTP_TELEMETRY_TOPIC, source);
    }

    //----------------------------------------------------------------------------
    // Attribute API

    /// @brief Sends the given key-value pair as attribute data.
    /// See https://thingsboard.io/docs/user-guide/attributes/ for more information
    /// @tparam T Type of the passed value
    /// @param key Non owning pointer to the key of the key-value pair.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the key-value pair
    /// @param value Value of the key-value pair
    /// @return Whether copying the key-value pair into the outgoing HTTP buffer, was successful or not
    template<typename T>
    bool Send_Attribute_Data(char const * key, T const & value) {
        return Send_Key_Value_Pair(key, value, false);
    }

    /// @brief Send aggregated key-value pair as attribute data
    /// @note Expects iterators to a container containing Attribute class instances.
    /// See https://thingsboard.io/docs/user-guide/attribute/ for more information
    /// @tparam InputIterator Class that allows for forward incrementable access to data
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @tparam MaxKeyValuePairAmount Maximum amount of key-value pairs, which will ever be sent with this method.
    /// Should simply be the biggest distance between first and last iterator this method is ever called with
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
#if THINGSBOARD_ENABLE_DYNAMIC
    template<typename InputIterator>
#else
    /// @tparam MaxKeyValuePairAmount Maximum amount of json key value pairs, which will ever be sent with this method to the cloud.
    /// Should simply be the biggest distance between first and last iterator this method is ever called with
    template<size_t MaxKeyValuePairAmount, typename InputIterator>
#endif // THINGSBOARD_ENABLE_DYNAMIC
    bool Send_Attributes(InputIterator const & first, InputIterator const & last) {
#if THINGSBOARD_ENABLE_DYNAMIC
        return Send_Data_Array(first, last, false);
#else
        return Send_Data_Array<MaxKeyValuePairAmount>(first, last, false);
#endif // THINGSBOARD_ENABLE_DYNAMIC
    }

    /// @brief Send string containing json as attribute data.
    /// See https://thingsboard.io/docs/user-guide/attribute/ for more information
    /// @param json Non owning pointer to the string containing our json key-value pairs
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the key-value pairs
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
    bool Send_Attribute_String(char const * json) {
        return Send_Json_String(HTTP_ATTRIBUTES_TOPIC, json);
    }

    /// @brief Send key-value pairs as attribute data.
    /// See https://thingsboard.io/docs/user-guide/attribute/ for more information
    /// @param source JsonDocument containing our json key-value pairs,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
    bool Send_Attribute_Json(JsonDocument const & source) {
        return Send_Json(HTTP_ATTRIBUTES_TOPIC, source);
    }

    //----------------------------------------------------------------------------
    // Generic HTTP API

    /// @brief Attempts to send a GET request over HTTP or HTTPS
    /// @param path API path we want to get data from (example: /api/v1/$TOKEN/rpc)
    /// @param response String the GET response will be copied into,
    /// will not be changed if the GET request wasn't successful
    /// @return Whetherr sending the GET request was successful or not
#if THINGSBOARD_ENABLE_STL
    bool Send_Get_Request(char const * path, std::string & response) {
#else
    bool Send_Get_Request(char const * path, String& response) {
#endif // THINGSBOARD_ENABLE_STL
        return Get_Message(path, response);
    }

    /// @brief Attempts to send a POST request over HTTP or HTTPS
    /// @param path API path we want to send data to (example: /api/v1/$TOKEN/attributes)
    /// @param json String containing our json key value pairs we want to attempt to send
    /// @return Whetherr sending the POST request was successful or not
    bool Send_Post_Request(char const * path, char const * json) {
        return Post_Message(path, json);
    }

  private:
    /// @brief Clears any remaining memory of the current TCP connection
    void Clear_Connection() {
        m_client.stop();
    }

    /// @brief Sends a HTTP POST request
    /// @param path Non owning pointer to the API path we want to call the POST request on.
    /// Does not need to kept alive as the function copies the data into the HTTP buffer to publish the POST request
    /// @param json Non owning pointer to the string the POST request will send.
    /// Does not need to kept alive as the function copies the data into the HTTP buffer to publish the POST request
    /// @return Whether executing the POST request and receiving a response was successful or not
    bool Post_Message(char const * path, char const * json) {
        bool success = m_client.post(path, HTTP_POST_PATH, json) == 0;
        int const status = m_client.get_response_status_code();

        if (!success || status < HTTP_RESPONSE_SUCCESS_RANGE_START || status > HTTP_RESPONSE_SUCCESS_RANGE_END) {
            Logger::printfln(HTTP_FAILED, POST, status);
            success = false;
        }

        Clear_Connection();
        return success;
    }

    /// @brief Sends a HTTP GET request
    /// @param path Non owning pointer to the API path we want to call the GET request on.
    /// Does not need to kept alive as the function copies the data into the HTTP buffer to publish the GET request
    /// @param response Editable reference to the string the GET response will be copied into, will not be changed if the GET request wasn't successful
    /// @return Whether executing the GET request and receiving a response was successful or not
#if THINGSBOARD_ENABLE_STL
    bool Get_Message(char const * path, std::string& response) {
#else
    bool Get_Message(char const * path, String& response) {
#endif // THINGSBOARD_ENABLE_STL
        bool success = m_client.get(path);
        int const status = m_client.get_response_status_code();

        if (!success || status < HTTP_RESPONSE_SUCCESS_RANGE_START || status > HTTP_RESPONSE_SUCCESS_RANGE_END) {
            Logger::printfln(HTTP_FAILED, GET, status);
            success = false;
            goto cleanup;
        }
        response = m_client.get_response_body();

        cleanup:
        Clear_Connection();
        return success;
    }

    /// @brief Send aggregated key-value pair as telemetry or attribute data
    /// @note Expects iterators to a container containing Telemetry class instances.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @tparam InputIterator Class that allows for forward incrementable access to data
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @tparam MaxKeyValuePairAmount Maximum amount of key-value pairs, which will ever be sent with this method.
    /// Should simply be the biggest distance between first and last iterator this method is ever called with
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether copying the key-value pairs into the outgoing HTTP buffer, was successful or not
#if THINGSBOARD_ENABLE_DYNAMIC
    template<typename InputIterator>
#else
    template<size_t MaxKeyValuePairAmount, typename InputIterator>
#endif // THINGSBOARD_ENABLE_DYNAMIC
    bool Send_Data_Array(InputIterator const & first, InputIterator const & last, bool telemetry) {
        auto const size = Helper::distance(first, last);
#if THINGSBOARD_ENABLE_DYNAMIC
        TBJsonDocument json_buffer(JSON_OBJECT_SIZE(size));
#else
        if (size > MaxKeyValuePairAmount) {
            Logger::printfln(TOO_MANY_JSON_FIELDS, size, "MaxKeyValuePairAmount", MaxKeyValuePairAmount);
            return false;
        }
        StaticJsonDocument<JSON_OBJECT_SIZE(MaxKeyValuePairAmount)> json_buffer;
#endif // THINGSBOARD_ENABLE_DYNAMIC

#if THINGSBOARD_ENABLE_STL
        if (std::any_of(first, last, [&json_buffer](Telemetry const & data) { return !data.SerializeKeyValue(json_buffer); })) {
            Logger::printfln(UNABLE_TO_SERIALIZE);
            return false;
        }
#else
        for (auto it = first; it != last; ++it) {
            auto const & data = *it;
            if (!data.SerializeKeyValue(json_buffer)) {
                Logger::printfln(UNABLE_TO_SERIALIZE);
                return false;
            }
        }
#endif // THINGSBOARD_ENABLE_STL
        return telemetry ? Send_Telemetry_Json(json_buffer) : Send_Attribute_Json(json_buffer);
    }

    /// @brief Sends the given key-value pair as telemtry or attribute data
    /// @tparam T Type of the passed value
    /// @param key Non owning pointer to the key of the key-value pair.
    /// Does not need to kept alive as the function copies the data into the outgoing HTTP buffer to publish the key-value pair
    /// @param value Value of the key-value pair
    /// @return Whether copying the key-value pair into the outgoing HTTP buffer, was successful or not
    template<typename T>
    bool Send_Key_Value_Pair(char const * key, T value, bool telemetry = true) {
        Telemetry const t(key, value);
        if (t.IsEmpty()) {
            // Message is ignored and not sent at all.
            return false;
        }

        StaticJsonDocument<JSON_OBJECT_SIZE(1)> json_buffer;
        if (!t.SerializeKeyValue(json_buffer)) {
            Logger::printfln(UNABLE_TO_SERIALIZE);
            return false;
        }
        return telemetry ? Send_Telemetry_Json(json_buffer) : Send_Attribute_Json(json_buffer);
    }

    IHTTP_Client& m_client = {};     // HttpClient instance
    size_t        m_max_stack = {};  // Maximum stack size we allocate at once on the stack.
    char const    *m_token = {};     // Access token used to connect with
};

using ThingsBoardHttp = ThingsBoardHttpSized<>;

#endif // ThingsBoard_Http_h
